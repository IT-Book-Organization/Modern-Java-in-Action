# Chapter 18. 함수형 관점으로 생각하기

<br/>

> (멀티코어 등의) 하드웨어 변경과 (데이터베이스의 질의와 비슷한 방식으로 데이터를 조작하는 등의) 프로그래머의 기대치 때문에  
> 결국 자바 소프트웨어 엔지니어의 프로그래밍 형식이 좀 더 `함수형`으로 다가갈 것이다.

<br/>

# 18.1 시스템 구현과 유지보수

함수형 프로그래밍은 `부작용 없음(no side effect)`과 `불변성(immutability)`라는 개념을 제공한다.

<br/>

## 18.11 공유된 가변 데이터

많은 프로그래머는 유지보수 중 코드 크래시 디버깅 문제를 가장 많이 겪게 되며, 코드 크래시는 예상하지 못한 변숫값 때문에 발견할 수 있다.

변수가 예상하지 못한 값을 갖는 이유는 시스템이 **여러 메서드에서 공유된 가변 데이터 구조를 읽고 갱신하기 때문**이다.

<br/>

공유 가변 데이터 구조를 사용하면 아래 그림처럼 프로그램 전체에서 데이터 갱신 사실을 추적하기가 어려워진다.

<br/>

<p align="center"><img width="550" alt="공유 가변 데이터 구조" src="https://user-images.githubusercontent.com/86337233/220951385-037b25ec-31fc-4257-a4ec-e34f5b161af4.png">

<br/>
<br/>

### 순수(pure) 메서드, 부작용 없는(side-effect free) 메서드

1. 자신을 포함하는 클래스의 상태 그리고 다른 객체의 상태를 바꾸지 않으며
2. return 문을 통해서만 자신의 결과를 반환하는 메서드를 말한다.

<br/>

- ‘`부작용`’은 함수 내에 포함되지 못한 기능을 말한다.
    - 자료구조를 고치거나 필드에 값을 할당(setter 메서드 같은 생성자 이외의 초기화 동작)
    - 예외 발생
    - 파일에 쓰기 등의 I/O 동작 수행


- 불변 객체를 이용해서 부작용을 없애는 방법도 있다.
    - `불변 객체` : 인스턴스화한 다음에는 객체의 상태를 바꿀 수 없는 객체


- 부작용 없는 시스템 컴포넌트에서는 메서드가 서로 간섭하는 일이 없으므로 잠금을 사용하지 않고도 멀티코어 병렬성을 사용할 수 있다.

<br/>
<br/>

## 18.1.2 선언형 프로그래밍

프로그램으로 시스템을 구현하는 방식 두 가지

1. `명령형 프로그래밍` : **작업을 ‘어떻게(how)’ 수행할 것인지**에 집중하는 형식
    - 고전의 객체지향 프로그래밍에서 이용하는 방식이다.


2. `선언형 프로그래밍` : **‘무엇을’ 수행할 것인지**에 집중하는 형식
    - 질의문 구현 방법은 라이브러리가 결정한다. (`내부 반복, internal iteration`)
    - e.g., 리스트에서 가장 비싼 트랜잭션을 계산하는 코드

        ```java
        Optional<Transaction> mostExpensive = transactions.stream()
        	.max(comparing(Transaction::getValue));
        ```

<br/>
<br/>

## 18.1.3 왜 함수형 프로그래밍인가?

함수형 프로그래밍은 선언형 프로그래밍을 따르는 대표적인 방식이며, 부작용이 없는 계산을 지향한다.

따라서 더 쉽게 시스템을 구현하고 유지보수할 수 있게 된다.

<br/>
<br/>
<br/>

# 18.2 함수형 프로그래밍이란 무엇인가?

- `함수형 프로그래밍` = 함수를 이용하는 프로그래밍


- `함수` = 수학적인 함수
    - 함수형 프로그래밍에서 함수는 0개 이상의 인수를 가지며,
      한 개 이상의 결과를 반환하지만 **부작용이 없어야 한다.**
    - 자바와 같은 언어에서는 바로 수학적인 함수냐 아니냐가 메서드와 함수를 구분하는 핵심이다.

<br/>

#### 부작용을 포함하는 함수

<p align="center"><img width="450" alt="부작용을 포함하는 함수" src="https://user-images.githubusercontent.com/86337233/220951399-66f7f409-8593-4529-85ef-8a9700c0dcef.png">

<br/>
<br/>

#### 부작용이 없는 함수

<p align="center"><img width="450" alt="부작용이 없는 함수" src="https://user-images.githubusercontent.com/86337233/220951406-62fbfb29-8ab3-403f-b1e9-d21d596741c2.png">

<br/>
<br/>

> ‘함수 그리고 if-then-else 등의 수학적 표현만 사용’하는 방식을 순수 함수형 프로그래밍이라고 하며  
> ’**시스템의 다른 부분에 영향을 미치지 않는다면** 내부적으로는 함수형이 아닌 기능도 사용’하는 방식을 함수형 프로그래밍이라 한다.

<br/>
<br/>

## 18.2.1 함수형 자바

실질적으로 자바로는 완벽한 순수 함수형 프로그래밍을 구현하기 어렵기에 순수 함수형이 아니라 **함수형 프로그램**을 구현할 것이다.

<br/>

> 1️⃣ 함수나 메서드는 **지역 변수만을 변경해야** 함수형이라 할 수 있다.

<br/>

> 2️⃣ 함수나 메서드에서 참조하는 객체가 있다면 그 객체는 `불변 객체`여야 한다.

즉, 객체의 모든 필드가 `final`이어야 하고 모든 참조 필드는 불변 객체를 직접 참조해야 한다.

<br/>

> 3️⃣ 예외적으로 메서드 내에서 생성한 객체의 필드는 갱신할 수 있다.

단, 새로 생성한 객체의 필드 갱신이 외부에 노출되지 않아야 하고, 다음에 메서드를 다시 호출한 결과에 영향을 미치지 않아야 한다.

<br/>

> 4️⃣ 함수형이라면 함수나 메서드가 어떤 예외도 일으키지 않아야 한다.

예외가 발생하면 return으로 결과를 반환할 수 없게 될 수 있기 때문이다.

<br/>

비정상적인 입력값(e.g., 0을 어떤 수로 나누는 상황)이 있을 때 처리되지 않은 예외를 일으키는 것이 자연스러운 방식일 것인데,  
예외를 처리하는 과정에서 함수형에 위배되는 제어 흐름이 발생한다면 결국 ‘인수를 전달해서 결과를 받는다’는 모델이 깨지게 된다.

따라서 세 번째 화살표가 추가된다.

<br/>

<p align="center"><img width="450" alt="예외를 일으키는 함수" src="https://user-images.githubusercontent.com/86337233/220951413-8e93ccff-1f01-4951-8cd3-12d956d57bcf.png">

<br/>
<br/>
<br/>

예외를 사용하지 않고 함수를 표현하려면 `Optional<T>`를 사용하면 된다.

이를 통해 예외 없이도 결과값으로 연산을 성공적으로 수행했는지, 수행하지 못했는지를 확인할 수 있다.

`Optional<T>`를 사용한다면 호출자는 메서드 호출 결과로 빈 Optional이 반환되는지를 확인해야 한다.

<br/>

> 5️⃣ 비함수형 동작을 감출 수 있는 상황에서만 부작용을 포함하는 라이브러리 함수를 사용해야 한다.

즉, 먼저 자료구조를 복사한다든가 발생할 수 있는 예제를 적절하게 내부적으로 처리함으로써 자료구조의 변경을 호출자가 알 수 없도록 감춰야 한다.

<br/>
<br/>

## 18.2.2 참조 투명성

‘부작용을 감춰야 한다’라는 제약은 `참조 투명성(referential transparency)` 개념으로 귀결된다.

즉, **같은 인수로 함수를 호출했을 때 항상 같은 결과를 반환한다면** 참조적으로 투명한 함수라고 표현한다.

<br/>

참조 투명성은 비싸거나 오랜 시간이 걸리는 연산을 기억화(memorization) 또는 캐싱(caching)을 통해 다시 계산하지 않고 저장하는 최적화 기능도 제공한다.

<br/>
<br/>
<br/>

# 18.3 재귀와 반복

순수 함수형 프로그래밍 언어에서는 while, for 같은 반복문 때문에 변화가 코드에 자연스럽게 스며들 수 있기에, 이들을 포함하지 않는다.

함수형 스타일에서는 다른 누군가가 변화를 알아차리지만 못한다면 아무 상관이 없으니 **지역 변수는 자유롭게 갱신할 수 있다.**

<br/>

하지만 다음 코드처럼 for-each 루프를 사용하는 검색 알고리즘은 문제가 될 수 있다.

```java
public void searchForGold(List<String> l, Stats stats) {
    for (String s : l) {
        if ("gold".equals(s)) {
            stats.incrementFor("gold");
            // 루프 내부에서 프로그램의 다른 부분과 공유되는 stats 객체의 상태를 변화시킴
            // → 함수형과 상충됨
        }
    }
}
```

<br/>

`재귀`를 통해 프로그램을 구현함으로써 이러한 문제를 해결할 수 있다.

- 이론적으로 반복을 이용하는 모든 프로그램은 재귀로도 구현할 수 있으며, 재귀를 이용하면 변화가 일어나지 않는다.
- 재귀를 이용하면 루프 단계마다 갱신되는 반복 변수를 제거할 수 있다.

<br/>

e.g., 팩토리얼

> 1️⃣ 반복 방식의 팩토리얼

```java
// 매 반복마다 변수 r과 i가 갱신됨
static int factorialIterative(int n) {
    int r = 1;
    for (int i = 1; i <= n; i++) {
        r *= i;
    }
    return r;
}
```

<br/>

> 2️⃣ 재귀 방식의 팩토리얼

```java
// 최종 연산 : n과 재귀 호출의 결과값의 곱셈
static int factorialRecursive(long n) {
    return n == 1 ? 1 : n * factorialRecursive(n - 1);
}
```

<br/>

일반적으로 반복 코드보다 재귀 코드가 더 비싸다.

함수를 호출할 때마다 호출 스택에 각 호출시 생성되는 정보를 저장할 새로운 스택 프레임이 만들어지기 때문이다.

즉, 재귀 팩토리얼에서는 입력값에 비례해서 메모리 사용량이 증가하게 된다.

<br/>

<p align="center"><img width="510" alt="재귀" src="https://user-images.githubusercontent.com/86337233/220951416-3707ee57-896c-435e-a0a6-5a0fb3a11827.png">

<br/>
<br/>

> 3️⃣ 꼬리 호출 최적화

위 재귀에 대한 해결책으로 함수형 언어에서는 `꼬리 호출 최적화(tail-call optimization)`를 제공한다.

```java
static long factorialTailRecursive(long n) {
    return factorialHelper(1, n);
}

// 꼬리 재귀 (재귀 호출이 가장 마지막에서 이루어짐)
static long factorialHelper(long acc, long n) {
    return n == 1 ? acc : factorialHelper(acc * n, n - 1);
}
```

<br/>

<p align="center"><img width="600" alt="꼬리 재귀" src="https://user-images.githubusercontent.com/86337233/220951424-5d7eb45e-eadd-40c8-a636-d400ca7d12b3.png">

<br/>
<br/>

- `일반 재귀` : 중간 결과를 각각 저장해야 한다.
- `꼬리 재귀` : 컴파일러가 하나의 스택 프레임을 재활용할 가능성이 생긴다.

<br/>

하지만 자바는 이와 같은 최적화를 제공하진 않는다.

그럼에도 여전히 고전적인 재귀보다는 여러 컴파일러 최적화 여지를 남겨둘 수 있는 꼬리 재귀를 적용하는 것이 좋다.

스칼라, 그루비 같은 최신 JVM 언어는 이와 같은 재귀를 반복으로 변환하는 최적화를 제공한다.

<br/>

> 4️⃣ 스트림 팩토리얼

자바 8에서는 반복을 스트림으로 대체해서 변화를 피할 수 있다.

```java
static int factorialStreams(long n) {
    return LongStream.rangeClosed(1, n)
        .reduce(1, (long a, long b) -> a * b);
}
```
